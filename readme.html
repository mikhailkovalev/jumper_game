<!doctype html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>
            Задачи по проекту
        </title>
        <script type="text/javascript">
            function make_id(idx)
            {
                return 'id_' + idx;
            }
            function make_ref(name, idx)
            {
                return '<a href="#' + make_id(idx) + '">' + name + '</a>';
            }

            function make_contents(){
                var headers = document.querySelectorAll("h3");
                var contents = '';
                for (i = 0; i < headers.length; i++)
               {
                   headers[i].id = make_id(i);
                   contents += make_ref(headers[i].innerHTML, i) + '<br>';
                }

                document.getElementById('contents').innerHTML = contents;
            }
        </script>
    </head>
    <body onload="make_contents();">
        <h2>
            Задачи по проекту
        </h2>
        <p id='contents'>
        </p>

        <h3> Правила почкования! </h3>
        <p>
            <ul>
                <li>
                    Каждой задаче выделяется отдельная ветка.
                </li>
                <li>
                    Если задача разбита на подзадачи, то каждой подзадаче
                    выделяем отдельную ветку.
                </li>
                <li>
                    После решения подзадачи мержим её в ветку задачи.
                </li>
                <li>
                    Скорее всего не имеет смысла выливать отдельные подзадачки
                    в master до полного решения задачи
                </li>
            </ul>
        </p>
        <h3>
            Задача 1: Приводим платформы в движение.
        </h3>
        <p>
            Задача достаточно сложная, поэтому будет разбита
            на подзадачи.
            Хотим, чтобы были выполнены следующие требования:
        </p>
        <ul>
            <li>
                Виды движения платформ:
                <ul>
                    <li>горизонтальное</li>
                    <li>вертикальное</li>
                    <li>
                        диагональное (как
                        совмещение первых
                        двух)
                    </li>
                </ul>
                Все движения платформ цикличны,
                т.е. в определённый момент времени
                направление движения платформы может
                смениться на прямо противоположное,
                что надо бы учесть в рассчёте
                взаимодействия дудлера и платформ.
            </li>
            <li>
                Новый закон взаимодействия дудлера и
                платформ должен учитывать то,
                что они находятся в движении
            </li>
            <li>
                У каждой платформы свой цикл движения.
                Нужно как-то давать понять, когда он
                заканчивается.
            </li>
            <li>
                Вообще говоря, статичные платформы
                являются частным случаем подвижных.
                Стоит ли отдельно рассматривать случаи
                статичных и подвижных платформ?
                Вообще говоря, как мне сейчас
                кажется стоит, по следующим причинам:
                <ul>
                    <li>
                        Если заведомо знаем, что платформа
                        неподвижна, это может ускорить время
                        рассчёта взаимодействия с ней;
                    </li>
                    <li>
                        Далее можно будет продолжить работу
                        над "исчезающими" платформами, для
                        взаимодействия с которыми должен быть
                        прописан отдельный закон;
                    </li>
                    <li>
                        Вообще говоря, кто сказал, что движущаяся платформа не
                        может исчезнуть? <i>Тут была идея с декораторами</i>,
                        но она забракована по причине того, что для всех тел
                        используется один единственный класс. Но отдельное
                        рассмотрение различных подвидов платформ остаётся. На
                        данный момент планируется реализовывать логику отличий
                        в различных классах законов, которые уже вполне могут
                        наследоваться друг от друга и/или декорароваться.
                        <br><b>ВАЖНЫЙ АРГУМЕНТ ПРОТИВ ДЕКОРИРОВАНИЯ:</b> Закон
                        един для всех тел, которые на него подписаны. Нельзя
                        задекорировать закон только для одного тела. Если
                        декорируем закон, то его декорирование распространится
                        на ВСЕ подписанные тела. Поэтому с декорированием
                        законов следует быть крайне осторожным. Вообще говоря,
                        декорировать законы можно только на этапе создания,
                        например: создал закон, сразу задекорировал, после чего
                        начал подписывать на него тела. Декорировать их в
                        runtime крайне нежелательно!
                    </li>
                    <li>
                        Ну, кстати, насчёт декораторов. Все платформы
                        являются объектами класса Body. Даже не наследниками.
                        Поэтому, всё же, лучше сделать какой-то такой алгоритм:
                        <ul>
                            <li>
                                При генерации платформ заведомо определяем её
                                тип и подписываем на соответствующий закон.
                            </li>
                            <li>
                                Да, придётся плодить законы, однако, уже там
                                вполне можно обойтись либо наследованием, либо
                                декорированием. Хотя насчёт декорирования:
                                скорее всего будет очень важен порядок
                                декорирования, потому что, если описывать
                                именно через декораторы, то каждый декоратор
                                будет описывать только одному ему присущую
                                особенность платформы, а учитывать это нужно
                                будет скорее всего одновременно.
                                <br><b>Пример:</b> движущаяся исчезающая
                                платформа.
                                <br><b>Другой пример:</b> платформа, от которой
                                можно оттолкнуться только тогда, когда она
                                находится в определённой точке своей
                                траектории.
                                <br><b>Ещё пример:</b>фальшивая платформа, при
                                взаимодействии с которой, она ломается и толчка
                                не происходит
                                <br><b>Такой-то пример:</b>Платформы с
                                бонусами. Пока что в перспективе, но тем не
                                менее, надо бы их учитывать.
                            </li>
                            <li>
                                В различных методах законов будем
                                инкапсулировать различные рекации и алгоритмы,
                                как то:
                                <ul>
                                    <li>
                                        вычисление времени до взаимодействия с
                                        платформой;
                                    </li>
                                    <li>
                                        изменение свойств платформы после
                                        взаимодействия с дудлом;
                                    </li>
                                    <li>
                                        изменение свойств дудла, после
                                        взаимодействия с платформой (должно
                                        очень помочь при описании различных
                                        бонусов или анти-бонусов в виде
                                        ломающихся платформ.)
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <h4>
            1.1. Сделать отдельный закон для обновления платформ.
        </h4>
        <p>
            На самом деле - это по-идее задача 2.1, но,
            поскольку всё уже сделано, то хер с ним.
        </p>
        <h4>
            1.2. Инкапсулировать в отдельный метод вычисление времени до
            взаимодействия дудла и платформы.
        </h4>
        <p>
            По-идее нужен рефакторинг имеющегося класса взаимодействия дудла и
            платформы. Текущий класс должен подразумевать взаимодействие дудла
            и статичной платформы. Постараться сделать хорошую декомпозицию
            логики, чтобы потом использовать в классах-наследниках, расширяющих
            данное поведение, готовый код, а не его дублирование.
        </p>
        <i><h5>
            Информация к размышлению
        </h5>
        <p>
            Платформ как-бы много, но дудл только один. Хорошо, пусть каждый
            вид платформ обрабатывается своим законом, но тогда следует
            задуматься на тему того, что мы получим то, что сначала, допустим
            произошла обработка законом для неподвижных платформ. И произошла
            или нет коллизия, у дудла, по завершении действия закона, изменятся
            параметры. И обработка следующего закона начнётся с изменёнными
            параметрами. Это плохо. Закон изменения атрибутов дудлера должен
            быть един для всех платформ. <br>Выход? <br>На данный момент в
            голову приходит что-то такое:
            <ul>
                <li>
                    каждая платформа хранит свой тип, как атрибут;
                </li>
                <li>
                    логика обнаружения и обработки коллизии выносится  из
                    законов в отдельные классы;
                </li>
                <li>
                    в законе взаимодействия дудла и платформ лежит словарь,
                    ключом которого является значение типа платформы, а по
                    значению лежит соответствующий обработчик.
                </li>
            </ul>
            Минусы такого подхода: где и как заполнять словарь
            "тип-обработчик"? <br>Возможное решение:
            <ul>
                <li>
                    в manager-е формируем тапл типов, по каждому типу передаём
                    экземпляр обработчика.
                </li>
            </ul>
            В этом случае Закону будет глубоко пофигу на конкретные значения
            типов платформ, и их конкретные значения будут инкапсулированы в
            manager-е. <br>Ещё минусы: начинаем по-особому обходиться с классом
            закона взаимодействия дудла и платформы, передавая ему словарь
            "тип-обработчик" для платформ. Однако, происходить это будет только
            на этапе создания. Потом этот закон будет использоваться точно
            также, как и остальные. Так что, возможно, это не такой уж и минус.
        </p></i>
        <h5>
            Промежуточный вывод
        </h5>
        <p>
            Создать набор Clash-классов <i><b>(нахуй оптимизацию, пусть сначала
            нормально заработает!)</b></i>, с примерно следующим интерфейсом:
            <ul>
                <li>
                    static<br>
                    нахождение минимального неотрицательного корня квадратного
                    уравнения
                </li>
                <li>
                    static<br>
                    проверка пересечения двух отрезков на числовой прямой
                </li>
                <li>
                    вычисление времени до столкновения с платформой
                </li>
                <li>
                    непосредственное разрешение коллизии, т.е. вычисление новой
                    скорости дудла
                </li>
            </ul>
        </p>
        <h3>
            Задача 2: Исчезающие платформы
        </h3>
        <p>
            Исчезновения платформ могут быть разных
            видов:
            <ul>
                <li>
                    исчезновение после прыжка на платформу
                </li>
                <li>
                    исчезновение после истечения некоторого времени её присутствия на экране
                </li>
                <li>
                    исчезновение после истечения некоторого времени с момента прыжка на эту платформу;
                </li>
            </ul>
            Manager должен не только проверять, вышли ли
            платформы за границу экрана, но и то,
            являются ли сами платформы действительными.
            Вообще говоря это надо бы вынести тоже в
            отдельный закон.
        </p>
        <h3>
            Задача 3. Добавить background.
        </h3>
        <p>
            Что нужно для добавления бэкграунда (далее БГ)?<br>
            БГ можно сделать обычным телом, у которого есть свой renderer, и,
            который подчиняется закону скроллинга... Вроде несложно...
        </p>
    </body>
</html>
