<!doctype html>
<html>
    <head>
        <meta charset="utf-8"/>
        <title>
            Задачи по проекту
        </title>
        <script type="text/javascript">
            function make_id(idx)
            {
                return 'id_' + idx;
            }
            function make_ref(name, idx)
            {
                return '<a href="#' + make_id(idx) + '">' + name + '</a>';
            }

            function make_contents(){
                var headers = document.querySelectorAll("h3");
                var contents = '';
                for (i = 0; i < headers.length; i++)
               {
                   headers[i].id = make_id(i);
                   contents += make_ref(headers[i].innerHTML, i) + '<br>';
                }

                document.getElementById('contents').innerHTML = contents;
            }
        </script>
    </head>
    <body onload="make_contents();">
        <h2>
            Задачи по проекту
        </h2>
        <p id='contents'>
        </p>

        <h3> Правила почкования! </h3>
        <p>
            <ul>
                <li>
                    Каждой задаче выделяется отдельная ветка.
                </li>
                <li>
                    Если задача разбита на подзадачи, то каждой подзадаче
                    выделяем отдельную ветку.
                </li>
                <li>
                    После решения подзадачи мержим её в ветку задачи.
                </li>
                <li>
                    Скорее всего не имеет смысла выливать отдельные подзадачки
                    в master до полного решения задачи
                </li>
            </ul>
        </p>
        <h3>
            Задача 1: Приводим платформы в движение.
        </h3>
        <p>
            Задача достаточно сложная, поэтому будет разбита
            на подзадачи.
            Хотим, чтобы были выполнены следующие требования:
        </p>
        <ul>
            <li>
                Виды движения платформ:
                <ul>
                    <li>горизонтальное</li>
                    <li>вертикальное</li>
                    <li>
                        диагональное (как
                        совмещение первых
                        двух)
                    </li>
                </ul>
                Все движения платформ цикличны,
                т.е. в определённый момент времени
                направление движения платформы может
                смениться на прямо противоположное,
                что надо бы учесть в рассчёте
                взаимодействия дудлера и платформ.
            </li>
            <li>
                Новый закон взаимодействия дудлера и
                платформ должен учитывать то,
                что они находятся в движении
            </li>
            <li>
                У каждой платформы свой цикл движения.
                Нужно как-то давать понять, когда он
                заканчивается.
            </li>
            <li>
                Вообще говоря, статичные платформы
                являются частным случаем подвижных.
                Стоит ли отдельно рассматривать случаи
                статичных и подвижных платформ?
                Вообще говоря, как мне сейчас
                кажется стоит, по следующим причинам:
                <ul>
                    <li>
                        Если заведомо знаем, что платформа
                        неподвижна, это может ускорить время
                        рассчёта взаимодействия с ней;
                    </li>
                    <li>
                        Далее можно будет продолжить работу
                        над "исчезающими" платформами, для
                        взаимодействия с которыми должен быть
                        прописан отдельный закон;
                    </li>
                    <li>
                        Вообще говоря, кто сказал, что движущаяся платформа не
                        может исчезнуть? <i>Тут была идея с декораторами</i>,
                        но она забракована по причине того, что для всех тел
                        используется один единственный класс. Но отдельное
                        рассмотрение различных подвидов платформ остаётся. На
                        данный момент планируется реализовывать логику отличий
                        в различных классах законов, которые уже вполне могут
                        наследоваться друг от друга и/или декорароваться.
                        <br><b>ВАЖНЫЙ АРГУМЕНТ ПРОТИВ ДЕКОРИРОВАНИЯ:</b> Закон
                        един для всех тел, которые на него подписаны. Нельзя
                        задекорировать закон только для одного тела. Если
                        декорируем закон, то его декорирование распространится
                        на ВСЕ подписанные тела. Поэтому с декорированием
                        законов следует быть крайне осторожным. Вообще говоря,
                        декорировать законы можно только на этапе создания,
                        например: создал закон, сразу задекорировал, после чего
                        начал подписывать на него тела. Декорировать их в
                        runtime крайне нежелательно!
                    </li>
                    <li>
                        Ну, кстати, насчёт декораторов. Все платформы
                        являются объектами класса Body. Даже не наследниками.
                        Поэтому, всё же, лучше сделать какой-то такой алгоритм:
                        <ul>
                            <li>
                                При генерации платформ заведомо определяем её
                                тип и подписываем на соответствующий закон.
                            </li>
                            <li>
                                Да, придётся плодить законы, однако, уже там
                                вполне можно обойтись либо наследованием, либо
                                декорированием. Хотя насчёт декорирования:
                                скорее всего будет очень важен порядок
                                декорирования, потому что, если описывать
                                именно через декораторы, то каждый декоратор
                                будет описывать только одному ему присущую
                                особенность платформы, а учитывать это нужно
                                будет скорее всего одновременно.
                                <br><b>Пример:</b> движущаяся исчезающая
                                платформа.
                                <br><b>Другой пример:</b> платформа, от которой
                                можно оттолкнуться только тогда, когда она
                                находится в определённой точке своей
                                траектории.
                                <br><b>Ещё пример:</b>фальшивая платформа, при
                                взаимодействии с которой, она ломается и толчка
                                не происходит
                                <br><b>Такой-то пример:</b>Платформы с
                                бонусами. Пока что в перспективе, но тем не
                                менее, надо бы их учитывать.
                            </li>
                            <li>
                                В различных методах законов будем
                                инкапсулировать различные рекации и алгоритмы,
                                как то:
                                <ul>
                                    <li>
                                        вычисление времени до взаимодействия с
                                        платформой;
                                    </li>
                                    <li>
                                        изменение свойств платформы после
                                        взаимодействия с дудлом;
                                    </li>
                                    <li>
                                        изменение свойств дудла, после
                                        взаимодействия с платформой (должно
                                        очень помочь при описании различных
                                        бонусов или анти-бонусов в виде
                                        ломающихся платформ.)
                                    </li>
                                </ul>
                            </li>
                        </ul>
                    </li>
                </ul>
            </li>
        </ul>
        <h4>
            1.1. Сделать отдельный закон для обновления платформ.
        </h4>
        <p>
            На самом деле - это по-идее задача 2.1, но,
            поскольку всё уже сделано, то хер с ним.
        </p>
        <h4>
            1.2. Инкапсулировать в отдельный метод вычисление времени до
            взаимодействия дудла и платформы.
        </h4>
        <p>
            По-идее нужен рефакторинг имеющегося класса взаимодействия дудла и
            платформы. Текущий класс должен подразумевать взаимодействие дудла
            и статичной платформы. Постараться сделать хорошую декомпозицию
            логики, чтобы потом использовать в классах-наследниках, расширяющих
            данное поведение, готовый код, а не его дублирование.
        </p>
        <i><h5>
            Информация к размышлению
        </h5>
        <p>
            Платформ как-бы много, но дудл только один. Хорошо, пусть каждый
            вид платформ обрабатывается своим законом, но тогда следует
            задуматься на тему того, что мы получим то, что сначала, допустим
            произошла обработка законом для неподвижных платформ. И произошла
            или нет коллизия, у дудла, по завершении действия закона, изменятся
            параметры. И обработка следующего закона начнётся с изменёнными
            параметрами. Это плохо. Закон изменения атрибутов дудлера должен
            быть един для всех платформ. <br>Выход? <br>На данный момент в
            голову приходит что-то такое:
            <ul>
                <li>
                    каждая платформа хранит свой тип, как атрибут;
                </li>
                <li>
                    логика обнаружения и обработки коллизии выносится  из
                    законов в отдельные классы;
                </li>
                <li>
                    в законе взаимодействия дудла и платформ лежит словарь,
                    ключом которого является значение типа платформы, а по
                    значению лежит соответствующий обработчик.
                </li>
            </ul>
            Минусы такого подхода: где и как заполнять словарь
            "тип-обработчик"? <br>Возможное решение:
            <ul>
                <li>
                    в manager-е формируем тапл типов, по каждому типу передаём
                    экземпляр обработчика.
                </li>
            </ul>
            В этом случае Закону будет глубоко пофигу на конкретные значения
            типов платформ, и их конкретные значения будут инкапсулированы в
            manager-е. <br>Ещё минусы: начинаем по-особому обходиться с классом
            закона взаимодействия дудла и платформы, передавая ему словарь
            "тип-обработчик" для платформ. Однако, происходить это будет только
            на этапе создания. Потом этот закон будет использоваться точно
            также, как и остальные. Так что, возможно, это не такой уж и минус.
        </p></i>
        <h5>
            Промежуточный вывод
        </h5>
        <p>
            Создать набор Clash-классов <i><b>(нахуй оптимизацию, пусть сначала
            нормально заработает!)</b></i>, с примерно следующим интерфейсом:
            <ul>
                <li>
                    static<br>
                    нахождение минимального неотрицательного корня квадратного
                    уравнения
                </li>
                <li>
                    static<br>
                    проверка пересечения двух отрезков на числовой прямой
                </li>
                <li>
                    вычисление времени до столкновения с платформой
                </li>
                <li>
                    непосредственное разрешение коллизии, т.е. вычисление новой
                    скорости дудла
                </li>
            </ul>
        </p>
        <h4>
            1.3 Непосредственное добавление движущихся платформ.
        </h4>
        <ol>
            <li>
                для новых платформ хотелось бы юзать другие цвета. поэтому надо
                написать какой-нибудь алгоритм, который бы преобразовывал
                цвета.<br>В данный момент подходящим кажется такая функция:
                f_c(c) = c ^ gamma, где аргумент функции - исходное значение
                компоненты цвета, а gamma = ln(c2)/ln(c1), где c1 - значение
                аргумента, а c2 - значение, достигаемое функцией при этом
                аргументе. На месте параметра c могут стоять компоненты r, g,
                b.
            </li>
            <li>
                создадим новый тип в enum-е типов платформ
            </li>
            <li>
                Для движущихся (и не только движущихся) платформ нужен особый
                порядок создания. Возможно имеет смысл говорить о вынесении
                кода создания платформ в отдельные классы. Сделать это можно
                примерно следующим образом: когда генерируем платформу,то мы
                генерируем её тип, а дальше по типу из соответствующего
                словаря, который можно хранить в том же енуме, будем получать
                объект, который будет получать ссылку на платформу и задавать
                ей все остальные параметры, в том числе, возможно, подписывать
                на законы. Хотя насчёт законов - это уже спорный момент, ибо
                инстансы законов хранятся в менеджере. Возможно словарь лучше
                задать не в енуме, а в менеджере. По ключу словаря будет лежать
                тоже словарь, хранящий генератор данных, а также законы. На
                самом деле всё это как-то херово, ибо при перегенерации
                платформы нужно переподписать её на новые законы, а код
                повторной генерации платформ уже вынесен в отдельный закон,
                который не имеет доступа к инстансу менеджера.
                <br><i><b>Выход?</b>Возможно в менеджере стоит сразу создать по
                некоторому количеству платформ каждого типа, при создании
                подписать их на законы, а при перегенерировании положения
                просто передавать платформы в их генераторы. Таким образом
                будем иметь следующее:
                <ul>
                    <li>
                        Енум хранит словарь, в котором каждому типу ставится в
                        соответствие объект-генератор данных платформы для
                        этого типа;
                    </li>
                    <li>
                        Менеджер сразу создаёт все платформы, которые так или
                        иначе будут использоваться и при создании сразу
                        подписывает их на законы, которым эти платформы будут
                        подчиняться.
                    </li>
                    <li>
                        Классы-генераторы данных для платформ получают на вход
                        платформу; при этом положение платформы пусть они не
                        задают, так как эта часть всё же является общей для
                        всех платформ и должна быть сконцентрирована в одном
                        месте: в законе, обновляющем платформы.
                    </li>
                </ul></i>
            </li>
            <li>
                Движущиеся платформы должны иметь следующие параметры:
                полупериод движения и остаток времени до окончяния периода. Они
                должны быть подписаны на отдельный закон, который будет
                отнимать от "остатка" прошедший интервал времени, а, если
                разность будет отрицательной, то менять параметры движения
                платформы (в том числе время до окончания уже нового
                полупериода).
            </li>
            <li>
                напишем обработчик столкновений (он должен учитывать, что
                платформа какое-то время движется в одну сторону, а после - в
                противоположную. в связи с этим начать, наверное следует с
                горизонтально-движущихся платформ, ибо их по-идее обрабатывать
                проще, но с другой стороны - горизонтальная платформа по-идее
                неплохой буст для дудла, поэтому вероятность их появления
                должна быть очень маленькой.)
            </li>
            <li>
                Рендерер платформ остаётся один; в енум типов платформ добавим
                словарь цветов платформ (у стандартной цветом сделать None?);
                рендерер, при своём конструировании, будет считывать словарь
                цветов, в процессе чего будет формировать свой словарь, ключами
                которого также останутся типы, а значениями будут объекты
                Image, хранящие спрайт платформы, подогнанный под нужный цвет.
                Во время рендеринга будет считываться тип платформы и
                извлекаться из словаря нужный спрайт.
            </li>
            <li>
                Нужно ввести понятия типа "верхняя граница влияния" и "нижняя
                граница влияния" для платформ. Теперь в алгоритме "генерации"
                новых платформ будем считывать, для вычисления самой высокой
                платформы, не её игрековую координату, а именно верхнюю границу
                влияния.<br><br>Теперь у платформ появляется понятие "зона
                влияния"<br><br>Генерировать платформы, стоит попробовать,
                пачками: первая платформа в "пачке" должна обеспечить
                продвижение выше, все остальные могут генериться в любом месте,
                которое "выше" экрана (т.е. их там не видно), главным
                требованием будет требование о том, чтобы границы влияния
                платформ не пересекались (по-идее сделать это не так сложно), а
                чтобы не проверять вообще все платформы каждый раз, их можно
                фильтровать и пробегаться только по отфильтрованным.
            </li>
        </ol>
        <h3>
            Задача 2: Исчезающие платформы
        </h3>
        <p>
            Исчезновения платформ могут быть разных
            видов:
            <ul>
                <li>
                    исчезновение после прыжка на платформу
                </li>
                <li>
                    исчезновение после истечения некоторого времени её присутствия на экране
                </li>
                <li>
                    исчезновение после истечения некоторого времени с момента прыжка на эту платформу;
                </li>
            </ul>
            Manager должен не только проверять, вышли ли
            платформы за границу экрана, но и то,
            являются ли сами платформы действительными.
            Вообще говоря это надо бы вынести тоже в
            отдельный закон.
        </p>
        <h3>
            Задача 3. Добавить background.
        </h3>
        <p>
            Что нужно для добавления бэкграунда (далее БГ)?<br>
            БГ можно сделать обычным телом, у которого есть свой renderer, и,
            который подчиняется закону скроллинга... Вроде несложно...
        </p>
    </body>
</html>
